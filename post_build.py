import re
import fileinput
from pathlib import Path
from os.path import commonprefix


def post_build(builder, ext):
    patch_include(builder, ext)
    generate_enums(builder, ext)


def patch_include(builder, ext):
    'Replaces #include instances in header files that use <> with "" for relative includes'
    install_dir = builder.get_install_dir(ext) + "/include"
    for path in Path(install_dir).rglob("*.h"):
        with fileinput.FileInput(str(path), inplace=True, backup=".bak") as fp:
            for fline in fp:
                line = str(fline)
                if line.strip().startswith("#include"):
                    include = line.split()[1]
                    if include[0] == "<" and include[-1] == ">":
                        include = include[1:-1]
                        if (path.parents[0] / include).exists():
                            print(line.replace(f"<{include}>", f'"{include}"'), end="")
                            continue
                print(line, end="")


ENUM_CLASS = """

class {name}(Enum):
    \"""
    {docs}
    \"""

    _prefix = "{prefix}"
    _suffix = "{suffix}"
    _values = {values}
"""

REPLACE = {
    "{": " { ",
    "}": " } ",
    ",": " , ",
    "=": " = ",
    ";": " ; ",
}
PATTERN = re.compile("|".join((re.escape(k) for k in REPLACE.keys())), flags=re.DOTALL)


def commonsuffix(words):
    reverse = lambda word: word[::-1]
    words = list(map(reverse, words))
    return commonprefix(words)[::-1]


def parse_enum(lines):
    from cppyy import gbl
    
    assert lines[0].startswith("typedef enum")

    # getting comments:
    comments = {}
    for i, line in enumerate(lines):
        if "//" in line:
            line, comment = line.split("//")
            line = line.strip()
            comment = comment.strip()
            lines[i] = line
            key = PATTERN.sub(lambda x: REPLACE[x.group(0)], line).split()[0]
            comments[key] = comment

    words = PATTERN.sub(lambda x: REPLACE[x.group(0)], " ".join(lines)).split()
    assert words[-1] == ";"

    name = words[-2]
    enums = []
    for i in range(len(words)):
        if words[i] in ["{", ","]:
            enums.append(words[i + 1])

    prefix = commonprefix(enums).lower()
    suffix = commonsuffix(enums).lower()
    clean = (
        lambda word: word[len(prefix) : -len(suffix)] if suffix else word[len(prefix) :]
    )

    comments = {
        clean(key.lower()): "    # " + val
        for key, val in comments.items()
        if key in enums
    }

    # Generating values
    values = {clean(key.lower()): int(getattr(gbl, key)) for key in enums}

    # Generating docs
    docs = [f"{key} = {val}{comments.get(key,'')}" for key, val in values.items()]
    docs = "\n    ".join(docs)

    return ENUM_CLASS.format(
        name=name, prefix=prefix, suffix=suffix, values=values, docs=docs
    )


OUTPUT = """
"List of QUDA enumerations"

# NOTE: This file is automathically generated by gen_enums.py
# DO NOT CHANGE MANUALLY but exeute
# python gen_enums.py

from .enum import Enum
"""


def generate_enums(builder, ext):
    "Reads enum_quda.h and returns the content of enums.py"
    from cppyy import include

    package_dir = builder.get_install_dir(ext)
    header = package_dir + "/include/enum_quda.h"
    include(header)
    header = open(header)
    lines = header.readlines()
    header.close()

    # packing groups of enums and then calling parse_enum
    pack = []
    out=OUTPUT
    for line in lines:
        line = line.strip()
        if line.startswith("typedef enum"):
            pack.append(line)
        elif pack:
            pack.append(line)
        if pack and line.endswith(";"):
            out += parse_enum(pack)
            pack = []

    filename = package_dir + "/enums.py"
    with open(filename, "w") as fp:
        fp.write(out)

    from black import format_file_in_place, Mode, Path, WriteBack
    format_file_in_place(Path(filename), False, Mode(), write_back=WriteBack.YES)
