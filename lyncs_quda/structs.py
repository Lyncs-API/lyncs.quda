"List of QUDA parameter structures"

# NOTE: This file is automathically generated by setup.py
# DO NOT CHANGE MANUALLY but reinstall the package
# python setup.py develop

from .enums import *
from .struct import Struct


class QudaGaugeParam(Struct):
    """
    QudaGaugeParam struct:
    - location : The location of the gauge field
    - X : The local space-time dimensions (without checkboarding)
    - anisotropy : Used for Wilson and Wilson-clover
    - tadpole_coeff : Used for staggered only
    - scale : Used by staggered long links
    - type : The link type of the gauge field (e.g., Wilson, fat, long, etc.)
    - gauge_order : The ordering on the input gauge field
    - t_boundary : The temporal boundary condition that will be used for fermion fields
    - cpu_prec : The precision used by the caller
    - cuda_prec : The precision of the cuda gauge field
    - reconstruct : The reconstruction type of the cuda gauge field
    - cuda_prec_sloppy : The precision of the sloppy gauge field
    - reconstruct_sloppy : The recontruction type of the sloppy gauge field
    - cuda_prec_refinement_sloppy : The precision of the sloppy gauge field for the refinement step in multishift
    - reconstruct_refinement_sloppy : The recontruction type of the sloppy gauge field for the refinement step in multishift
    - cuda_prec_precondition : The precision of the preconditioner gauge field
    - reconstruct_precondition : The recontruction type of the preconditioner gauge field
    - cuda_prec_eigensolver : The precision of the eigensolver gauge field
    - reconstruct_eigensolver : The recontruction type of the eigensolver gauge field
    - gauge_fix : Whether the input gauge field is in the axial gauge or not
    - ga_pad : The pad size that the cudaGaugeField will use (default=0)
    - site_ga_pad : Used by link fattening and the gauge and fermion forces
    - staple_pad : Used by link fattening
    - llfat_ga_pad : Used by link fattening
    - mom_ga_pad : Used by the gauge and fermion forces
    - staggered_phase_type : Set the staggered phase type of the links
    - staggered_phase_applied : Whether the staggered phase has already been applied to the links
    - i_mu : Imaginary chemical potential
    - overlap : Width of overlapping domains
    - overwrite_mom : When computing momentum, should we overwrite it or accumulate to to
    - use_resident_gauge : Use the resident gauge field as input
    - use_resident_mom : Use the resident momentum field as input
    - make_resident_gauge : Make the result gauge field resident
    - make_resident_mom : Make the result momentum field resident
    - return_result_gauge : Return the result gauge field
    - return_result_mom : Return the result momentum field
    - gauge_offset : Offset into MILC site struct to the gauge field (only if gauge_order=MILC_SITE_GAUGE_ORDER)
    - mom_offset : Offset into MILC site struct to the momentum field (only if gauge_order=MILC_SITE_GAUGE_ORDER)
    - site_size : Size of MILC site struct (only if gauge_order=MILC_SITE_GAUGE_ORDER)
    """

    _types = {
        "location": "QudaFieldLocation",
        "X": "int [ 4 ]",
        "anisotropy": "double",
        "tadpole_coeff": "double",
        "scale": "double",
        "type": "QudaLinkType",
        "gauge_order": "QudaGaugeFieldOrder",
        "t_boundary": "QudaTboundary",
        "cpu_prec": "QudaPrecision",
        "cuda_prec": "QudaPrecision",
        "reconstruct": "QudaReconstructType",
        "cuda_prec_sloppy": "QudaPrecision",
        "reconstruct_sloppy": "QudaReconstructType",
        "cuda_prec_refinement_sloppy": "QudaPrecision",
        "reconstruct_refinement_sloppy": "QudaReconstructType",
        "cuda_prec_precondition": "QudaPrecision",
        "reconstruct_precondition": "QudaReconstructType",
        "cuda_prec_eigensolver": "QudaPrecision",
        "reconstruct_eigensolver": "QudaReconstructType",
        "gauge_fix": "QudaGaugeFixed",
        "ga_pad": "int",
        "site_ga_pad": "int",
        "staple_pad": "int",
        "llfat_ga_pad": "int",
        "mom_ga_pad": "int",
        "staggered_phase_type": "QudaStaggeredPhase",
        "staggered_phase_applied": "int",
        "i_mu": "double",
        "overlap": "int",
        "overwrite_mom": "int",
        "use_resident_gauge": "int",
        "use_resident_mom": "int",
        "make_resident_gauge": "int",
        "make_resident_mom": "int",
        "return_result_gauge": "int",
        "return_result_mom": "int",
        "gauge_offset": "size_t",
        "mom_offset": "size_t",
        "site_size": "size_t",
    }


class QudaInvertParam(Struct):
    """
    QudaInvertParam struct:
    - input_location : The location of the input field
    - output_location : The location of the output field
    - dslash_type : The Dirac Dslash type that is being used
    - inv_type : Which linear solver to use
    - mass : Used for staggered only
    - kappa : Used for Wilson and Wilson-clover
    - m5 : Domain wall height
    - Ls : Extent of the 5th dimension (for domain wall)
    - b_5 : Mobius coefficients - only real part used if regular Mobius
    - c_5 : Mobius coefficients - only real part used if regular Mobius
    - eofa_shift : The following specifies the EOFA parameters. Notation follows arXiv:1706.05843
        * eofa_shift: the "\beta" in the paper
        * eofa_pm: plus or minus for the EOFA operator
        * mq1, mq2, mq3 are the three masses corresponds to Hasenbusch mass spliting.
        * As far as I know mq1 is always the same as "mass" but it's here just for consistence.
    - eofa_pm :
    - mq1 :
    - mq2 :
    - mq3 :
    - mu : Twisted mass parameter
    - epsilon : Twisted mass parameter
    - twist_flavor : Twisted mass flavor
    - laplace3D : omit this direction from laplace operator: x,y,z,t -> 0,1,2,3 (-1 is full 4D)
    - tol : Solver tolerance in the L2 residual norm
    - tol_restart : Solver tolerance in the L2 residual norm (used to restart InitCG)
    - tol_hq : Solver tolerance in the heavy quark residual norm
    - compute_true_res : Whether to compute the true residual post solve
    - true_res : Actual L2 residual norm achieved in solver
    - true_res_hq : Actual heavy quark residual norm achieved in solver
    - maxiter : Maximum number of iterations in the linear solver
    - reliable_delta : Reliable update tolerance
    - reliable_delta_refinement : Reliable update tolerance used in post multi-shift solver refinement
    - use_alternative_reliable : Whether to use alternative reliable updates
    - use_sloppy_partial_accumulator : Whether to keep the partial solution accumuator in sloppy precision
    - solution_accumulator_pipeline : This parameter determines how often we accumulate into the
        solution vector from the direction vectors in the solver.
        E.g., running with solution_accumulator_pipeline = 4, means we
        will update the solution vector every four iterations using the
        direction vectors from the prior four iterations.  This
        increases performance of mixed-precision solvers since it means
        less high-precision vector round-trip memory travel, but
        requires more low-precision memory allocation.
    - max_res_increase : This parameter determines how many consecutive reliable update
        residual increases we tolerate before terminating the solver,
        i.e., how long do we want to keep trying to converge
    - max_res_increase_total : This parameter determines how many total reliable update
        residual increases we tolerate before terminating the solver,
        i.e., how long do we want to keep trying to converge
    - max_hq_res_increase : This parameter determines how many consecutive heavy-quark
        residual increases we tolerate before terminating the solver,
        i.e., how long do we want to keep trying to converge
    - max_hq_res_restart_total : This parameter determines how many total heavy-quark residual
        restarts we tolerate before terminating the solver, i.e., how long
        do we want to keep trying to converge
    - heavy_quark_check : After how many iterations shall the heavy quark residual be updated
    - pipeline : Whether to use a pipelined solver with less global sums
    - num_offset : Number of offsets in the multi-shift solver
    - num_src : Number of sources in the multiple source solver
    - num_src_per_sub_partition : Number of sources in the multiple source solver, but per sub-partition
    - split_grid : The grid of sub-partition according to which the processor grid will be partitioned.
        Should have:
        split_grid[0] * split_grid[1] * split_grid[2] * split_grid[3] * num_src_per_sub_partition == num_src.
    - overlap : Width of domain overlaps
    - offset : Offsets for multi-shift solver
    - tol_offset : Solver tolerance for each offset
    - tol_hq_offset : Solver tolerance for each shift when refinement is applied using the heavy-quark residual
    - true_res_offset : Actual L2 residual norm achieved in solver for each offset
    - iter_res_offset : Iterated L2 residual norm achieved in multi shift solver for each offset
    - true_res_hq_offset : Actual heavy quark residual norm achieved in solver for each offset
    - residue : Residuals in the partial faction expansion
    - compute_action : Whether we should evaluate the action after the linear solver
    - action : Computed value of the bilinear action (complex-valued)
        invert: \phi^\dagger A^{-1} \phi
        multishift: \phi^\dagger r(x) \phi = \phi^\dagger (sum_k residue[k] * (A + offset[k])^{-1} ) \phi
    - solution_type : Type of system to solve
    - solve_type : How to solve it
    - matpc_type : The preconditioned matrix type
    - dagger : Whether we are using the Hermitian conjugate system or not
    - mass_normalization : The mass normalization is being used by the caller
    - solver_normalization : The normalization desired in the solver
    - preserve_source : Preserve the source or not in the linear solver (deprecated)
    - cpu_prec : The precision used by the input fermion fields
    - cuda_prec : The precision used by the QUDA solver
    - cuda_prec_sloppy : The precision used by the QUDA sloppy operator
    - cuda_prec_refinement_sloppy : The precision of the sloppy gauge field for the refinement step in multishift
    - cuda_prec_precondition : The precision used by the QUDA preconditioner
    - cuda_prec_eigensolver : The precision used by the QUDA eigensolver
    - dirac_order : The order of the input and output fermion fields
    - gamma_basis : Gamma basis of the input and output host fields
    - clover_location : The location of the clover field
    - clover_cpu_prec : The precision used for the input clover field
    - clover_cuda_prec : The precision used for the clover field in the QUDA solver
    - clover_cuda_prec_sloppy : The precision used for the clover field in the QUDA sloppy operator
    - clover_cuda_prec_refinement_sloppy : The precision of the sloppy clover field for the refinement step in multishift
    - clover_cuda_prec_precondition : The precision used for the clover field in the QUDA preconditioner
    - clover_cuda_prec_eigensolver : The precision used for the clover field in the QUDA eigensolver
    - clover_order : The order of the input clover field
    - use_init_guess : Whether to use an initial guess in the solver or not
    - clover_coeff : Coefficient of the clover term
    - clover_rho : Real number added to the clover diagonal (not to inverse)
    - compute_clover_trlog : Whether to compute the trace log of the clover term
    - trlogA : The trace log of the clover term (even/odd computed separately)
    - compute_clover : Whether to compute the clover field
    - compute_clover_inverse : Whether to compute the clover inverse field
    - return_clover : Whether to copy back the clover matrix field
    - return_clover_inverse : Whether to copy back the inverted clover matrix field
    - verbosity : The verbosity setting to use in the solver
    - sp_pad : The padding to use for the fermion fields
    - cl_pad : The padding to use for the clover fields
    - iter : The number of iterations performed by the solver
    - gflops : The Gflops rate of the solver
    - secs : The time taken by the solver
    - tune : Enable auto-tuning? (default = QUDA_TUNE_YES)
    - Nsteps : Number of steps in s-step algorithms
    - gcrNkrylov : Maximum size of Krylov space used by solver
    - inv_type_precondition : The following parameters are related to the solver
        * preconditioner, if enabled.
        *
        * The inner Krylov solver used in the preconditioner.  Set to
        * QUDA_INVALID_INVERTER to disable the preconditioner entirely.
    - preconditioner : Preconditioner instance, e.g., multigrid
    - deflation_op : Deflation instance
    - eig_param : defines deflation
    - deflate : If true, deflate the initial guess
    - dslash_type_precondition : Dirac Dslash used in preconditioner
    - verbosity_precondition : Verbosity of the inner Krylov solver
    - tol_precondition : Tolerance in the inner solver
    - maxiter_precondition : Maximum number of iterations allowed in the inner solver
    - omega : Relaxation parameter used in GCR-DD (default = 1.0)
    - ca_basis : Basis for CA algorithms
    - ca_lambda_min : Minimum eigenvalue for Chebyshev CA basis
    - ca_lambda_max : Maximum eigenvalue for Chebyshev CA basis
    - precondition_cycle : Number of preconditioner cycles to perform per iteration
    - schwarz_type : Whether to use additive or multiplicative Schwarz preconditioning
    - residual_type : Whether to use the L2 relative residual, Fermilab heavy-quark
        * residual, or both to determine convergence.  To require that both
        * stopping conditions are satisfied, use a bitwise OR as follows:
        *
        * p.residual_type = (QudaResidualType) (QUDA_L2_RELATIVE_RESIDUAL
        *                                     | QUDA_HEAVY_QUARK_RESIDUAL);
    - cuda_prec_ritz : Parameters for deflated solvers*/* The precision of the Ritz vectors
    - n_ev : How many vectors to compute after one solve
        *  for eigCG recommended values 8 or 16
    - max_search_dim : EeigCG  : Search space dimension
        *  gmresdr : Krylov subspace dimension
    - rhs_idx : For systems with many RHS: current RHS index
    - deflation_grid : Specifies deflation space volume: total number of eigenvectors is n_ev*deflation_grid
    - eigenval_tol : eigCG: selection criterion for the reduced eigenvector set
    - eigcg_max_restarts : mixed precision eigCG tuning parameter:  minimum search vector space restarts
    - max_restart_num : initCG tuning parameter:  maximum restarts
    - inc_tol : initCG tuning parameter:  tolerance for cg refinement corrections in the deflation stage
    - make_resident_solution : Whether to make the solution vector(s) after the solve
    - use_resident_solution : Whether to use the resident solution vector(s)
    - chrono_make_resident : Whether to use the solution vector to augment the chronological basis
    - chrono_replace_last : Whether the solution should replace the last entry in the chronology
    - chrono_use_resident : Whether to use the resident chronological basis
    - chrono_max_dim : The maximum length of the chronological history to store
    - chrono_index : The index to indicate which chrono history we are augmenting
    - chrono_precision : Precision to store the chronological basis in
    - extlib_type : Which external library to use in the linear solvers (MAGMA or Eigen)
    - native_blas_lapack : Whether to use the platform native or generic BLAS / LAPACK
    """

    _types = {
        "input_location": "QudaFieldLocation",
        "output_location": "QudaFieldLocation",
        "dslash_type": "QudaDslashType",
        "inv_type": "QudaInverterType",
        "mass": "double",
        "kappa": "double",
        "m5": "double",
        "Ls": "int",
        "b_5": "double_complex [ QUDA_MAX_DWF_LS ]",
        "c_5": "double_complex [ QUDA_MAX_DWF_LS ]",
        "eofa_shift": "double",
        "eofa_pm": "int",
        "mq1": "double",
        "mq2": "double",
        "mq3": "double",
        "mu": "double",
        "epsilon": "double",
        "twist_flavor": "QudaTwistFlavorType",
        "laplace3D": "int",
        "tol": "double",
        "tol_restart": "double",
        "tol_hq": "double",
        "compute_true_res": "int",
        "true_res": "double",
        "true_res_hq": "double",
        "maxiter": "int",
        "reliable_delta": "double",
        "reliable_delta_refinement": "double",
        "use_alternative_reliable": "int",
        "use_sloppy_partial_accumulator": "int",
        "solution_accumulator_pipeline": "int",
        "max_res_increase": "int",
        "max_res_increase_total": "int",
        "max_hq_res_increase": "int",
        "max_hq_res_restart_total": "int",
        "heavy_quark_check": "int",
        "pipeline": "int",
        "num_offset": "int",
        "num_src": "int",
        "num_src_per_sub_partition": "int",
        "split_grid": "int [ QUDA_MAX_DIM ]",
        "overlap": "int",
        "offset": "double [ QUDA_MAX_MULTI_SHIFT ]",
        "tol_offset": "double [ QUDA_MAX_MULTI_SHIFT ]",
        "tol_hq_offset": "double [ QUDA_MAX_MULTI_SHIFT ]",
        "true_res_offset": "double [ QUDA_MAX_MULTI_SHIFT ]",
        "iter_res_offset": "double [ QUDA_MAX_MULTI_SHIFT ]",
        "true_res_hq_offset": "double [ QUDA_MAX_MULTI_SHIFT ]",
        "residue": "double [ QUDA_MAX_MULTI_SHIFT ]",
        "compute_action": "int",
        "action": "double [ 2 ]",
        "solution_type": "QudaSolutionType",
        "solve_type": "QudaSolveType",
        "matpc_type": "QudaMatPCType",
        "dagger": "QudaDagType",
        "mass_normalization": "QudaMassNormalization",
        "solver_normalization": "QudaSolverNormalization",
        "preserve_source": "QudaPreserveSource",
        "cpu_prec": "QudaPrecision",
        "cuda_prec": "QudaPrecision",
        "cuda_prec_sloppy": "QudaPrecision",
        "cuda_prec_refinement_sloppy": "QudaPrecision",
        "cuda_prec_precondition": "QudaPrecision",
        "cuda_prec_eigensolver": "QudaPrecision",
        "dirac_order": "QudaDiracFieldOrder",
        "gamma_basis": "QudaGammaBasis",
        "clover_location": "QudaFieldLocation",
        "clover_cpu_prec": "QudaPrecision",
        "clover_cuda_prec": "QudaPrecision",
        "clover_cuda_prec_sloppy": "QudaPrecision",
        "clover_cuda_prec_refinement_sloppy": "QudaPrecision",
        "clover_cuda_prec_precondition": "QudaPrecision",
        "clover_cuda_prec_eigensolver": "QudaPrecision",
        "clover_order": "QudaCloverFieldOrder",
        "use_init_guess": "QudaUseInitGuess",
        "clover_coeff": "double",
        "clover_rho": "double",
        "compute_clover_trlog": "int",
        "trlogA": "double [ 2 ]",
        "compute_clover": "int",
        "compute_clover_inverse": "int",
        "return_clover": "int",
        "return_clover_inverse": "int",
        "verbosity": "QudaVerbosity",
        "sp_pad": "int",
        "cl_pad": "int",
        "iter": "int",
        "gflops": "double",
        "secs": "double",
        "tune": "QudaTune",
        "Nsteps": "int",
        "gcrNkrylov": "int",
        "inv_type_precondition": "QudaInverterType",
        "preconditioner": "void *",
        "deflation_op": "void *",
        "eig_param": "void *",
        "deflate": "QudaBoolean",
        "dslash_type_precondition": "QudaDslashType",
        "verbosity_precondition": "QudaVerbosity",
        "tol_precondition": "double",
        "maxiter_precondition": "int",
        "omega": "double",
        "ca_basis": "QudaCABasis",
        "ca_lambda_min": "double",
        "ca_lambda_max": "double",
        "precondition_cycle": "int",
        "schwarz_type": "QudaSchwarzType",
        "residual_type": "QudaResidualType",
        "cuda_prec_ritz": "QudaPrecision",
        "n_ev": "int",
        "max_search_dim": "int",
        "rhs_idx": "int",
        "deflation_grid": "int",
        "eigenval_tol": "double",
        "eigcg_max_restarts": "int",
        "max_restart_num": "int",
        "inc_tol": "double",
        "make_resident_solution": "int",
        "use_resident_solution": "int",
        "chrono_make_resident": "int",
        "chrono_replace_last": "int",
        "chrono_use_resident": "int",
        "chrono_max_dim": "int",
        "chrono_index": "int",
        "chrono_precision": "QudaPrecision",
        "extlib_type": "QudaExtLibType",
        "native_blas_lapack": "QudaBoolean",
    }


class QudaEigParam(Struct):
    """
    QudaEigParam struct:
    - invert_param : EIGENSOLVER PARAMS-------------------------------------------------* Used to store information pertinent to the operator
    - eig_type : Type of eigensolver algorithm to employ
    - use_poly_acc : Use Polynomial Acceleration
    - poly_deg : Degree of the Chebysev polynomial
    - a_min : Range used in polynomial acceleration
    - a_max :
    - preserve_deflation : Whether to preserve the deflation space between solves.  If
        true, the space will be stored in an instance of the
        deflation_space struct, pointed to by preserve_deflation_space
    - preserve_deflation_space : This is where we store the deflation space.  This will point
        to an instance of deflation_space. When a deflated solver is enabled, the deflation space will be obtained from this.
    - preserve_evals : If we restore the deflation space, this boolean indicates
        whether we are also preserving the evalues or recomputing
        them.  For example if a different mass shift is being used
        than the one used to generate the space, then this should be
        false, but preserve_deflation would be true
    - use_dagger : What type of Dirac operator we are using **/* If !(use_norm_op) && !(use_dagger) use M. **/* If use_dagger, use Mdag **/* If use_norm_op, use MdagM **/* If use_norm_op && use_dagger use MMdag.
    - use_norm_op :
    - use_eigen_qr : Use Eigen routines to eigensolve the upper Hessenberg via QR
    - compute_svd : Performs an MdagM solve, then constructs the left and right SVD.
    - compute_gamma5 : Performs the \gamma_5 OP solve by Post multipling the eignvectors with
        \gamma_5 before computing the eigenvalues
    - require_convergence : If true, the solver will error out if the convergence criteria are not met
    - spectrum : Which part of the spectrum to solve
    - n_ev : Size of the eigenvector search space
    - n_kr : Total size of Krylov space
    - nLockedMax : Max number of locked eigenpairs (deduced at runtime)
    - n_conv : Number of requested converged eigenvectors
    - n_ev_deflate : Number of requested converged eigenvectors to use in deflation
    - tol : Tolerance on the least well known eigenvalue's residual
    - qr_tol : Tolerance on the QR iteration
    - check_interval : For IRLM/IRAM, check every nth restart
    - max_restarts : For IRLM/IRAM, quit after n restarts
    - batched_rotate : For the Ritz rotation, the maximal number of extra vectors the solver may allocate
    - block_size : For block method solvers, the block size
    - arpack_check : In the test function, cross check the device result against ARPACK
    - arpack_logfile : For Arpack cross check, name of the Arpack logfile
    - QUDA_logfile : Name of the QUDA logfile (residua, upper Hessenberg/tridiag matrix updates)
    - nk : EIG-CG PARAMS
    - np :
    - import_vectors : Whether to load eigenvectors
    - cuda_prec_ritz : The precision of the Ritz vectors
    - mem_type_ritz : The memory type used to keep the Ritz vectors
    - location : Location where deflation should be done
    - run_verify : Whether to run the verification checks once set up is complete
    - vec_infile : Filename prefix where to load the null-space vectors
    - vec_outfile : Filename prefix for where to save the null-space vectors
    - save_prec : The precision with which to save the vectors
    - io_parity_inflate : Whether to inflate single-parity eigen-vector I/O to a full
        field (e.g., enabling this is required for compatability with
        MILC I/O)
    - gflops : The Gflops rate of the eigensolver setup
    - secs : The time taken by the eigensolver setup
    - extlib_type : Which external library to use in the deflation operations (MAGMA or Eigen)
    """

    _types = {
        "invert_param": "QudaInvertParam *",
        "eig_type": "QudaEigType",
        "use_poly_acc": "QudaBoolean",
        "poly_deg": "int",
        "a_min": "double",
        "a_max": "double",
        "preserve_deflation": "QudaBoolean",
        "preserve_deflation_space": "void *",
        "preserve_evals": "QudaBoolean",
        "use_dagger": "QudaBoolean",
        "use_norm_op": "QudaBoolean",
        "use_eigen_qr": "QudaBoolean",
        "compute_svd": "QudaBoolean",
        "compute_gamma5": "QudaBoolean",
        "require_convergence": "QudaBoolean",
        "spectrum": "QudaEigSpectrumType",
        "n_ev": "int",
        "n_kr": "int",
        "nLockedMax": "int",
        "n_conv": "int",
        "n_ev_deflate": "int",
        "tol": "double",
        "qr_tol": "double",
        "check_interval": "int",
        "max_restarts": "int",
        "batched_rotate": "int",
        "block_size": "int",
        "arpack_check": "QudaBoolean",
        "arpack_logfile": "char [ 512 ]",
        "QUDA_logfile": "char [ 512 ]",
        "nk": "int",
        "np": "int",
        "import_vectors": "QudaBoolean",
        "cuda_prec_ritz": "QudaPrecision",
        "mem_type_ritz": "QudaMemoryType",
        "location": "QudaFieldLocation",
        "run_verify": "QudaBoolean",
        "vec_infile": "char [ 256 ]",
        "vec_outfile": "char [ 256 ]",
        "save_prec": "QudaPrecision",
        "io_parity_inflate": "QudaBoolean",
        "gflops": "double",
        "secs": "double",
        "extlib_type": "QudaExtLibType",
    }


class QudaMultigridParam(Struct):
    """
    QudaMultigridParam struct:
    - invert_param :
    - eig_param :
    - n_level : Number of multigrid levels
    - geo_block_size : Geometric block sizes to use on each level
    - spin_block_size : Spin block sizes to use on each level
    - n_vec : Number of null-space vectors to use on each level
    - precision_null : Precision to store the null-space vectors in (post block orthogonalization)
    - n_block_ortho : Number of times to repeat Gram-Schmidt in block orthogonalization
    - verbosity : Verbosity on each level of the multigrid
    - setup_inv_type : Inverter to use in the setup phase
    - num_setup_iter : Number of setup iterations
    - setup_tol : Tolerance to use in the setup phase
    - setup_maxiter : Maximum number of iterations for each setup solver
    - setup_maxiter_refresh : Maximum number of iterations for refreshing the null-space vectors
    - setup_ca_basis : Basis to use for CA-CGN(E/R) setup
    - setup_ca_basis_size : Basis size for CACG setup
    - setup_ca_lambda_min : Minimum eigenvalue for Chebyshev CA basis
    - setup_ca_lambda_max : Maximum eigenvalue for Chebyshev CA basis
    - setup_type : Null-space type to use in the setup phase
    - pre_orthonormalize : Pre orthonormalize vectors in the setup phase
    - post_orthonormalize : Post orthonormalize vectors in the setup phase
    - coarse_solver : The solver that wraps around the coarse grid correction and smoother
    - coarse_solver_tol : Tolerance for the solver that wraps around the coarse grid correction and smoother
    - coarse_solver_maxiter : Maximum number of iterations for the solver that wraps around the coarse grid correction and smoother
    - coarse_solver_ca_basis : Basis to use for CA-CGN(E/R) coarse solver
    - coarse_solver_ca_basis_size : Basis size for CACG coarse solver
    - coarse_solver_ca_lambda_min : Minimum eigenvalue for Chebyshev CA basis
    - coarse_solver_ca_lambda_max : Maximum eigenvalue for Chebyshev CA basis
    - smoother : Smoother to use on each level
    - smoother_tol : Tolerance to use for the smoother / solver on each level
    - nu_pre : Number of pre-smoother applications on each level
    - nu_post : Number of post-smoother applications on each level
    - omega : Over/under relaxation factor for the smoother at each level
    - smoother_halo_precision : Precision to use for halo communication in the smoother
    - smoother_schwarz_type : Whether to use additive or multiplicative Schwarz preconditioning in the smoother
    - smoother_schwarz_cycle : Number of Schwarz cycles to apply
    - coarse_grid_solution_type : The type of residual to send to the next coarse grid, and thus the
        type of solution to receive back from this coarse grid
    - smoother_solve_type : The type of smoother solve to do on each grid (e/o preconditioning or not)
    - cycle_type : The type of multigrid cycle to perform at each level
    - global_reduction : Whether to use global reductions or not for the smoother / solver at each level
    - location : Location where each level should be done
    - setup_location : Location where the coarse-operator construction will be computedn
    - use_eig_solver : Whether to use eigenvectors for the nullspace or, if the coarsest instance deflate
    - setup_minimize_memory : Minimize device memory allocations during the adaptive setup,
        placing temporary fields in mapped memory instad of device
        memory
    - compute_null_vector : Whether to compute the null vectors or reload them
    - generate_all_levels : Whether to generate on all levels or just on level 0
    - run_verify : Whether to run the verification checks once set up is complete
    - run_low_mode_check : Whether to run null Vs eigen vector overlap checks once set up is complete
    - run_oblique_proj_check : Whether to run null vector oblique checks once set up is complete
    - vec_load : Whether to load the null-space vectors to disk (requires QIO)
    - vec_infile : Filename prefix where to load the null-space vectors
    - vec_store : Whether to store the null-space vectors to disk (requires QIO)
    - vec_outfile : Filename prefix for where to save the null-space vectors
    - coarse_guess : Whether to use and initial guess during coarse grid deflation
    - preserve_deflation : Whether to preserve the deflation space during MG update
    - gflops : The Gflops rate of the multigrid solver setup
    - secs : The time taken by the multigrid solver setup
    - mu_factor : Multiplicative factor for the mu parameter
    - transfer_type : Boolean for aggregation type, implies staggered or not
    - use_mma : Whether to use tensor cores (if available)
    - thin_update_only : Whether to do a full (false) or thin (true) update in the context of updateMultigridQuda
    """

    _types = {
        "invert_param": "QudaInvertParam *",
        "eig_param": "QudaEigParam * [ QUDA_MAX_MG_LEVEL ]",
        "n_level": "int",
        "geo_block_size": "int [ QUDA_MAX_MG_LEVEL ] [ QUDA_MAX_DIM ]",
        "spin_block_size": "int [ QUDA_MAX_MG_LEVEL ]",
        "n_vec": "int [ QUDA_MAX_MG_LEVEL ]",
        "precision_null": "QudaPrecision [ QUDA_MAX_MG_LEVEL ]",
        "n_block_ortho": "int [ QUDA_MAX_MG_LEVEL ]",
        "verbosity": "QudaVerbosity [ QUDA_MAX_MG_LEVEL ]",
        "setup_inv_type": "QudaInverterType [ QUDA_MAX_MG_LEVEL ]",
        "num_setup_iter": "int [ QUDA_MAX_MG_LEVEL ]",
        "setup_tol": "double [ QUDA_MAX_MG_LEVEL ]",
        "setup_maxiter": "int [ QUDA_MAX_MG_LEVEL ]",
        "setup_maxiter_refresh": "int [ QUDA_MAX_MG_LEVEL ]",
        "setup_ca_basis": "QudaCABasis [ QUDA_MAX_MG_LEVEL ]",
        "setup_ca_basis_size": "int [ QUDA_MAX_MG_LEVEL ]",
        "setup_ca_lambda_min": "double [ QUDA_MAX_MG_LEVEL ]",
        "setup_ca_lambda_max": "double [ QUDA_MAX_MG_LEVEL ]",
        "setup_type": "QudaSetupType",
        "pre_orthonormalize": "QudaBoolean",
        "post_orthonormalize": "QudaBoolean",
        "coarse_solver": "QudaInverterType [ QUDA_MAX_MG_LEVEL ]",
        "coarse_solver_tol": "double [ QUDA_MAX_MG_LEVEL ]",
        "coarse_solver_maxiter": "int [ QUDA_MAX_MG_LEVEL ]",
        "coarse_solver_ca_basis": "QudaCABasis [ QUDA_MAX_MG_LEVEL ]",
        "coarse_solver_ca_basis_size": "int [ QUDA_MAX_MG_LEVEL ]",
        "coarse_solver_ca_lambda_min": "double [ QUDA_MAX_MG_LEVEL ]",
        "coarse_solver_ca_lambda_max": "double [ QUDA_MAX_MG_LEVEL ]",
        "smoother": "QudaInverterType [ QUDA_MAX_MG_LEVEL ]",
        "smoother_tol": "double [ QUDA_MAX_MG_LEVEL ]",
        "nu_pre": "int [ QUDA_MAX_MG_LEVEL ]",
        "nu_post": "int [ QUDA_MAX_MG_LEVEL ]",
        "omega": "double [ QUDA_MAX_MG_LEVEL ]",
        "smoother_halo_precision": "QudaPrecision [ QUDA_MAX_MG_LEVEL ]",
        "smoother_schwarz_type": "QudaSchwarzType [ QUDA_MAX_MG_LEVEL ]",
        "smoother_schwarz_cycle": "int [ QUDA_MAX_MG_LEVEL ]",
        "coarse_grid_solution_type": "QudaSolutionType [ QUDA_MAX_MG_LEVEL ]",
        "smoother_solve_type": "QudaSolveType [ QUDA_MAX_MG_LEVEL ]",
        "cycle_type": "QudaMultigridCycleType [ QUDA_MAX_MG_LEVEL ]",
        "global_reduction": "QudaBoolean [ QUDA_MAX_MG_LEVEL ]",
        "location": "QudaFieldLocation [ QUDA_MAX_MG_LEVEL ]",
        "setup_location": "QudaFieldLocation [ QUDA_MAX_MG_LEVEL ]",
        "use_eig_solver": "QudaBoolean [ QUDA_MAX_MG_LEVEL ]",
        "setup_minimize_memory": "QudaBoolean",
        "compute_null_vector": "QudaComputeNullVector",
        "generate_all_levels": "QudaBoolean",
        "run_verify": "QudaBoolean",
        "run_low_mode_check": "QudaBoolean",
        "run_oblique_proj_check": "QudaBoolean",
        "vec_load": "QudaBoolean [ QUDA_MAX_MG_LEVEL ]",
        "vec_infile": "char [ QUDA_MAX_MG_LEVEL ] [ 256 ]",
        "vec_store": "QudaBoolean [ QUDA_MAX_MG_LEVEL ]",
        "vec_outfile": "char [ QUDA_MAX_MG_LEVEL ] [ 256 ]",
        "coarse_guess": "QudaBoolean",
        "preserve_deflation": "QudaBoolean",
        "gflops": "double",
        "secs": "double",
        "mu_factor": "double [ QUDA_MAX_MG_LEVEL ]",
        "transfer_type": "QudaTransferType [ QUDA_MAX_MG_LEVEL ]",
        "use_mma": "QudaBoolean",
        "thin_update_only": "QudaBoolean",
    }


class QudaGaugeObservableParam(Struct):
    """
    QudaGaugeObservableParam struct:
    - su_project : Whether to porject onto the manifold prior to measurement
    - compute_plaquette : Whether to compute the plaquette
    - plaquette : Total, spatial and temporal field energies, respectively
    - compute_qcharge : Whether to compute the topological charge and field energy
    - qcharge : Computed topological charge
    - energy : Total, spatial and temporal field energies, respectively
    - compute_qcharge_density : Whether to compute the topological charge density
    - qcharge_density : Pointer to host array of length volume where the q-charge density will be copied
    """

    _types = {
        "su_project": "QudaBoolean",
        "compute_plaquette": "QudaBoolean",
        "plaquette": "double [ 3 ]",
        "compute_qcharge": "QudaBoolean",
        "qcharge": "double",
        "energy": "double [ 3 ]",
        "compute_qcharge_density": "QudaBoolean",
        "qcharge_density": "void *",
    }


class QudaBLASParam(Struct):
    """
    QudaBLASParam struct:
    - trans_a : operation op(A) that is non- or (conj.) transpose.
    - trans_b : operation op(B) that is non- or (conj.) transpose.
    - m : number of rows of matrix op(A) and C.
    - n : number of columns of matrix op(B) and C.
    - k : number of columns of op(A) and rows of op(B).
    - lda : leading dimension of two-dimensional array used to store the matrix A.
    - ldb : leading dimension of two-dimensional array used to store matrix B.
    - ldc : leading dimension of two-dimensional array used to store matrix C.
    - a_offset : position of the A array from which begin read/write.
    - b_offset : position of the B array from which begin read/write.
    - c_offset : position of the C array from which begin read/write.
    - a_stride : stride of the A array in strided(batched) mode
    - b_stride : stride of the B array in strided(batched) mode
    - c_stride : stride of the C array in strided(batched) mode
    - alpha : scalar used for multiplication.
    - beta : scalar used for multiplication. If beta==0, C does not have to be a valid input.
    - batch_count : number of pointers contained in arrayA, arrayB and arrayC.
    - data_type : Specifies if using S(C) or D(Z) BLAS type
    - data_order : Specifies if using Row or Column major
    """

    _types = {
        "trans_a": "QudaBLASOperation",
        "trans_b": "QudaBLASOperation",
        "m": "int",
        "n": "int",
        "k": "int",
        "lda": "int",
        "ldb": "int",
        "ldc": "int",
        "a_offset": "int",
        "b_offset": "int",
        "c_offset": "int",
        "a_stride": "int",
        "b_stride": "int",
        "c_stride": "int",
        "alpha": "double_complex",
        "beta": "double_complex",
        "batch_count": "int",
        "data_type": "QudaBLASDataType",
        "data_order": "QudaBLASDataOrder",
    }
