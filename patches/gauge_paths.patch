diff --git a/include/gauge_field_order.h b/include/gauge_field_order.h
index 714ad7d..27f5560 100644
--- a/include/gauge_field_order.h
+++ b/include/gauge_field_order.h
@@ -1535,6 +1535,10 @@ namespace quda {
           }
         }
 
+        FloatNOrder(const GaugeField *u, Float *gauge_ = 0, Float **ghost_ = 0) :
+	  FloatNOrder(*u, gauge_, ghost_)
+	{}
+	
       __device__ __host__ inline void load(complex v[length / 2], int x, int dir, int parity, real phase = 1.0) const
       {
         const int M = reconLen / N;
diff --git a/include/gauge_path_helper.cuh b/include/gauge_path_helper.cuh
index d1c2ae5..43593a9 100644
--- a/include/gauge_path_helper.cuh
+++ b/include/gauge_path_helper.cuh
@@ -85,7 +85,7 @@ namespace quda {
      @param[in] dx Temporary shared memory storage for relative coordinate shift
   */
   template <typename Arg, typename I>
-  __device__ __host__ inline typename Arg::Link
+  __device__ __host__ inline typename Arg::Link&
   computeGaugePath(const Arg &arg, int x[4], int parity, const int* path, int length, I& dx)
   {
     using Link = typename Arg::Link;
@@ -93,7 +93,6 @@ namespace quda {
     // linkA: current matrix
     // linkB: the loaded matrix in this round
     Link linkA, linkB;
-    setIdentity(&linkA);
 
     int nbr_oddbit = parity;
 
@@ -104,19 +103,100 @@ namespace quda {
 
       if (isForwards(pathj)) {
         linkB = arg.u(lnkdir, linkIndexShift(x,dx,arg.E), nbr_oddbit);
-        linkA = linkA * linkB;
         dx[lnkdir]++; // now have to update to new location
         nbr_oddbit = nbr_oddbit^1;
       } else {
         dx[lnkdir]--; // if we are going backwards the link is on the adjacent site
         nbr_oddbit = nbr_oddbit^1;
         linkB = arg.u(lnkdir, linkIndexShift(x,dx,arg.E), nbr_oddbit);
-        linkA = linkA * conj(linkB);
+	linkB = conj(linkB);
       }
+      if (j>0)
+	linkA = linkA * linkB;
+      else
+	linkA = linkB;
     } //j
 
     return linkA;
   }
 
+  template <typename Link>
+  struct LinkPair {
+    Link A,B;
+  };
+
+  
+  /**
+     @brief Calculates an arbitary gauge path with insertion, returning the product matrix
+
+     @return The product of the gauge path
+     @param[in] arg Kernel argumnt
+     @param[in] x Full index array
+     @param[in] parity Parity index (note: assumes that an offset from a non-zero dx is baked in)
+     @param[in] path Gauge link path
+     @param[in] length Length of gauge path
+     @param[in] dx Temporary shared memory storage for relative coordinate shift
+  */
+  template <typename Arg, typename I>
+  __device__ __host__ inline LinkPair<typename Arg::Link>&
+  computeGaugePathWIns(const Arg &arg, int x[4], int parity, const int* path, int length, I& dx)
+  {
+    using Link = typename Arg::Link;
+
+    // aux[0]: current matrix
+    // aux[1]: the loaded matrix in this round
+    LinkPair<Link> out;
+    Link aux0, aux1, aux2;
+
+    int nbr_oddbit = parity;
+
+    for (int j = 0; j < length; j++) {
+
+      int pathj = path[j];
+      int lnkdir = isForwards(pathj) ? pathj : flipDir(pathj);
+
+      if (isForwards(pathj)) {
+	aux0 = arg.u(lnkdir, linkIndexShift(x,dx,arg.E), nbr_oddbit);
+	aux1 = arg.ins(lnkdir, linkIndexShift(x,dx,arg.E), nbr_oddbit);
+	if (not (arg.left and j==0)) {
+	  aux1 = aux1 * aux0;
+	}
+        dx[lnkdir]++; // now have to update to new location
+        nbr_oddbit = nbr_oddbit^1;
+      } else {
+        dx[lnkdir]--; // if we are going backwards the link is on the adjacent site
+        nbr_oddbit = nbr_oddbit^1;
+	aux0 = arg.u(lnkdir, linkIndexShift(x,dx,arg.E), nbr_oddbit);
+	aux0 = conj(aux0);
+	aux1 = arg.ins(lnkdir, linkIndexShift(x,dx,arg.E), nbr_oddbit);
+	if (not (arg.left and j==0)) {
+	  aux1 = - aux0 * aux1;
+	}
+      }
+
+      if (j>0) {
+	if(arg.left and j==1)
+	  out.B = out.A * aux1;
+	else
+	  out.B = out.B * aux0 + out.A * aux1;
+	out.A = out.A * aux0;
+      }
+      else if(arg.left) {
+	out.A = aux0;
+	aux2 = aux1;
+      }
+      else {
+	out.A = aux0;
+	out.B = aux1;
+      }
+    } //j
+
+    if(arg.left) {
+      out.B = out.B + out.A*aux2;
+    }
+    
+    return out;
+  }
+
 }
 
diff --git a/include/gauge_path_quda.h b/include/gauge_path_quda.h
index db398c1..79c4075 100644
--- a/include/gauge_path_quda.h
+++ b/include/gauge_path_quda.h
@@ -11,7 +11,7 @@ namespace quda
      @param[in] input_path Host-array holding all path contributions for the gauge action
      @param[in] length Host array holding the length of all paths
      @param[in] path_coeff Coefficient of each path
-     @param[in] num_paths Numer of paths
+     @param[in] num_paths Number of paths
      @param[in] max_length Maximum length of each path
    */
   void gaugeForce(GaugeField &mom, const GaugeField &u, double coeff, std::vector<int **> &input_path,
@@ -25,7 +25,7 @@ namespace quda
      @param[in] input_path Host-array holding all path contributions
      @param[in] length Host array holding the length of all paths
      @param[in] path_coeff Coefficient of each path
-     @param[in] num_paths Numer of paths
+     @param[in] num_paths Number of paths
      @param[in] max_length Maximum length of each path
    */
   void gaugePath(GaugeField &out, const GaugeField &u, double coeff, std::vector<int **> &input_path,
@@ -39,11 +39,37 @@ namespace quda
      @param[in] factor Multiplicative factor for each loop (i.e., volume normalization, etc)
      @param[in] length Host array holding the length of all paths
      @param[in] path_coeff Coefficient of each path
-     @param[in] num_paths Numer of paths
+     @param[in] num_paths Number of paths
      @param[in] path_max_length Maximum length of each path
    */
   void gaugeLoopTrace(const GaugeField &u, std::vector<Complex> &loop_traces, double factor,
                       std::vector<int **> &input_path, std::vector<int> &length, std::vector<double> &path_coeff_h,
                       int num_paths, int path_max_length);
 
+  /**
+     @brief Compute the product of gauge-links along the given paths
+     @param[out] out Array of scalar gauge field where the result is added to
+     @param[in] u Gauge field (extended when running on multiple GPUs)
+     @param[in] input_path Host-array holding all path contributions
+     @param[in] length Host array holding the length of all paths
+     @param[in] path_coeff Coefficient of each path
+     @param[in] num_paths Number of paths
+     @param[in] max_length Maximum length of each path
+   */
+  void gaugePaths(std::vector<GaugeField*> &out, const GaugeField &u, std::vector<int **> &input_path,
+		  std::vector<int> &length, std::vector<double> &path_coeff, int num_paths, int max_length);
+
+  /**
+     @brief Compute the product of gauge-links along the given paths inserting a gauge field at every step
+     @param[out] out Array of scalar gauge field where the result is added to
+     @param[in] u Gauge field (extended when running on multiple GPUs)
+     @param[in] ins Gauge field (extended when running on multiple GPUs)
+     @param[in] input_path Host-array holding all path contributions
+     @param[in] length Host array holding the length of all paths
+     @param[in] path_coeff Coefficient of each path
+     @param[in] num_paths Number of paths
+     @param[in] max_length Maximum length of each path
+   */
+  void gaugePathsWIns(std::vector<GaugeField*> &out, std::vector<GaugeField*> &out_wins, const GaugeField &u, const GaugeField &ins, bool left,
+		      std::vector<int **> &input_path, std::vector<int> &length, std::vector<double> &path_coeff, int num_paths, int max_length);
 } // namespace quda
