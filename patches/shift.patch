diff --git a/include/gauge_field.h b/include/gauge_field.h
index 706e82c..f75894c 100644
--- a/include/gauge_field.h
+++ b/include/gauge_field.h
@@ -394,6 +394,13 @@ namespace quda {
     virtual void copy(const GaugeField &src) = 0;
 
     /**
+     * Generic gauge field shift
+     * @param[in] src Source from which we are shifting
+     * @param[in] dx Host array of shifts to apply to the field
+     */
+    virtual void shift(const GaugeField &src, const int *dx) = 0;
+
+    /**
        @brief Compute the L1 norm of the field
        @param[in] dim Which dimension we are taking the norm of (dim=-1 mean all dimensions)
        @return L1 norm
@@ -544,6 +551,13 @@ namespace quda {
     void copy(const GaugeField &src);
 
     /**
+     * Generic gauge field shift
+     * @param[in] src Source from which we are shifting
+     * @param[in] dx Host array of shifts to apply to the field
+     */
+    void shift(const GaugeField &src, const int *dx);
+    
+    /**
        @brief Download into this field from a CPU field
        @param[in] cpu The CPU field source
     */
@@ -680,6 +694,13 @@ namespace quda {
      */
     void copy(const GaugeField &src);
 
+    /**
+     * Generic gauge field shift
+     * @param[in] src Source from which we are shifting
+     * @param[in] dx Host array of shifts to apply to the field
+     */
+    void shift(const GaugeField &src, const int *dx);
+    
     void* Gauge_p() { return gauge; }
     const void* Gauge_p() const { return gauge; }
 
@@ -872,4 +893,13 @@ namespace quda {
 
 #define checkReconstruct(...) Reconstruct_(__func__, __FILE__, __LINE__, __VA_ARGS__)
 
+  /**
+   * @brief Shift a gauge field
+   *
+   * @param Uout Gauge field to store output
+   * @param Uin Gauge field to shift
+   * @param dx shift in each direction
+   */
+  void gaugeShift(GaugeField &Uout, const GaugeField &Uin, const int *dx);
+  
 } // namespace quda
diff --git a/lib/CMakeLists.txt b/lib/CMakeLists.txt
index 492fdfb..dc8ded1 100644
--- a/lib/CMakeLists.txt
+++ b/lib/CMakeLists.txt
@@ -72,6 +72,7 @@ set (QUDA_OBJS
   copy_gauge_half.cu copy_gauge_quarter.cu
   copy_gauge.cpp copy_gauge_mg.cu copy_clover.cu
   copy_gauge_offset.cu copy_color_spinor_offset.cu copy_clover_offset.cu
+  gauge_shift.cu gauge_paths.cu gauge_paths_wins.cu
   staggered_oprod.cu clover_trace_quda.cu
   hisq_paths_force_quda.cu
   unitarize_force_quda.cu unitarize_links_quda.cu milc_interface.cpp
diff --git a/lib/cpu_gauge_field.cpp b/lib/cpu_gauge_field.cpp
index f4b2710..65c1d7f 100644
--- a/lib/cpu_gauge_field.cpp
+++ b/lib/cpu_gauge_field.cpp
@@ -334,6 +334,10 @@ namespace quda {
     }
   }
 
+  void cpuGaugeField::shift(const GaugeField &src, const int *dx) {
+    errorQuda("Not Implemented");
+  }
+  
   void cpuGaugeField::setGauge(void **gauge_)
   {
     if(create != QUDA_REFERENCE_FIELD_CREATE) {
diff --git a/lib/cuda_gauge_field.cpp b/lib/cuda_gauge_field.cpp
index 568209a..45565bd 100644
--- a/lib/cuda_gauge_field.cpp
+++ b/lib/cuda_gauge_field.cpp
@@ -610,6 +610,24 @@ namespace quda {
     qudaDeviceSynchronize(); // include sync here for accurate host-device profiling
   }
 
+  void cudaGaugeField::shift(const GaugeField &src, const int *dx) {
+    for(int i=0; i<this->nDim; i++) {
+      if (dx[i]!=0) break;
+      if (i == this->nDim-1) return this->copy(src);
+    }
+    if (this == &src) errorQuda("Cannot copy in itself");
+    
+    checkField(src);
+
+    // TODO: check src extension (needs to be enoug for shifting)
+
+    if (typeid(src) == typeid(cudaGaugeField)) {
+      gaugeShift(*this, src, dx);
+    } else {
+      errorQuda("Not compatible type");
+    }
+  }
+  
   void cudaGaugeField::loadCPUField(const cpuGaugeField &cpu) {
     copy(cpu);
     qudaDeviceSynchronize();
