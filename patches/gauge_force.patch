diff --git a/include/gauge_force_quda.h b/include/gauge_force_quda.h
index 6bf0477..295dbac 100644
--- a/include/gauge_force_quda.h
+++ b/include/gauge_force_quda.h
@@ -13,9 +13,11 @@ namespace quda {
      @param[in] path_coeff Coefficient of each path
      @param[in] num_paths Numer of paths
      @param[in] max_length Maximum length of each path
+     @param[in] per_dir (default true) Whether the input_path is given per direction
+                        or as a list of path where the first value indicates the direction
    */
   void gaugeForce(GaugeField& mom, const GaugeField& u, double coeff, int ***input_path,
-		  int *length, double *path_coeff, int num_paths, int max_length);
+		  int *length, double *path_coeff, int num_paths, int max_length, bool per_dir=true);
 
   /**
      @brief Compute the product of gauge-links along the given path
@@ -27,9 +29,11 @@ namespace quda {
      @param[in] path_coeff Coefficient of each path
      @param[in] num_paths Numer of paths
      @param[in] max_length Maximum length of each path
+     @param[in] per_dir (default true) Whether the input_path is given per direction
+                        or as a list of path where the first value indicates the direction
    */
-  void gaugePath(GaugeField &out, const GaugeField &u, double coeff, int ***input_path, int *length, double *path_coeff,
-                 int num_paths, int max_length);
+  void gaugePath(GaugeField &out, const GaugeField &u, double coeff, int ***input_path,
+		 int *length, double *path_coeff, int num_paths, int max_length, bool per_dir=true);
 } // namespace quda
 
 
diff --git a/include/kernels/gauge_force.cuh b/include/kernels/gauge_force.cuh
index 09b7f97..6d51cdb 100644
--- a/include/kernels/gauge_force.cuh
+++ b/include/kernels/gauge_force.cuh
@@ -16,14 +16,19 @@ namespace quda {
     const double *path_coeff;
     int *buffer;
     int count;
+    bool per_dir;
+    bool run_dir[4];
 
-    paths(int ***input_path, int *length_h, double *path_coeff_h, int num_paths, int max_length) :
+    paths(int ***input_path, int *length_h, double *path_coeff_h, int num_paths, int max_length, bool per_dir) :
       num_paths(num_paths),
       max_length(max_length),
-      count(0)
+      count(0),
+      per_dir(per_dir),
+      run_dir({per_dir,per_dir,per_dir,per_dir})
     {
       // create path struct in a single allocation
-      size_t bytes = 4 * num_paths * max_length * sizeof(int) + num_paths * sizeof(int);
+      int ndirs = per_dir ? 4 : 1;
+      size_t bytes = ndirs * num_paths * max_length * sizeof(int) + num_paths * sizeof(int);
       int pad = ((sizeof(double) - bytes % sizeof(double)) % sizeof(double))/sizeof(int);
       bytes += pad*sizeof(int) + num_paths*sizeof(double);
 
@@ -31,10 +36,17 @@ namespace quda {
       int *path_h = static_cast<int*>(safe_malloc(bytes));
       memset(path_h, 0, bytes);
 
-      for (int dir=0; dir<4; dir++) {
+      for (int dir=0; dir<ndirs; dir++) {
         // flatten the input_path array for copying to the device
         for (int i=0; i < num_paths; i++) {
           for (int j=0; j < length_h[i]; j++) {
+	    // checking that if not per_dir, first link is in positive direction
+	    if (not per_dir and j==0) {
+	      if(input_path[dir][i][j]>3) {
+		errorQuda("First path element must be in a positive direction");
+	      }
+	      run_dir[input_path[dir][i][j]]=true;
+	    }
             path_h[dir*num_paths*max_length + i*max_length + j] = input_path[dir][i][j];
             if (dir==0) count++;
           }
@@ -42,18 +54,18 @@ namespace quda {
       }
 
       // length array
-      memcpy(path_h + 4 * num_paths * max_length, length_h, num_paths*sizeof(int));
+      memcpy(path_h + ndirs * num_paths * max_length, length_h, num_paths*sizeof(int));
 
       // path_coeff array
-      memcpy(path_h + 4 * num_paths * max_length + num_paths + pad, path_coeff_h, num_paths*sizeof(double));
+      memcpy(path_h + ndirs * num_paths * max_length + num_paths + pad, path_coeff_h, num_paths*sizeof(double));
 
       qudaMemcpy(buffer, path_h, bytes, qudaMemcpyHostToDevice);
       host_free(path_h);
 
       // finally set the pointers to the correct offsets in the buffer
-      for (int d=0; d < 4; d++) this->input_path[d] = buffer + d*num_paths*max_length;
-      length = buffer + 4*num_paths*max_length;
-      path_coeff = reinterpret_cast<double*>(buffer + 4 * num_paths * max_length + num_paths + pad);
+      for (int d=0; d < ndirs; d++) this->input_path[d] = buffer + d*num_paths*max_length;
+      length = buffer + ndirs*num_paths*max_length;
+      path_coeff = reinterpret_cast<double*>(buffer + ndirs * num_paths * max_length + num_paths + pad);
     }
     void free() {
       pool_device_free(buffer);
@@ -117,9 +129,18 @@ namespace quda {
       real coeff = arg.p.path_coeff[i];
       if (coeff == 0) continue;
 
-      const int* path = arg.p.input_path[dir] + i*arg.p.max_length;
+      const int* path = arg.p.input_path[arg.p.per_dir ? dir : 0] + i*arg.p.max_length;
+      if (not arg.p.per_dir and path[0] != dir) continue;
 
+      int length = arg.p.length[i];
+      if (not arg.p.per_dir) {
+	// Skipping first link
+	length -= 1;
+	path += 1;
+      }
+      
       // start from end of link in direction dir
+      for(int i=0; i<4; i++) dx[i] = 0;
       int nbr_oddbit = (parity^1);
       dx[dir]++;
 
@@ -138,7 +159,7 @@ namespace quda {
         linkA = conj(linkB);
       }
 
-      for (int j=1; j<arg.p.length[i]; j++) {
+      for (int j=1; j<length; j++) {
 
         int pathj = path[j];
         int lnkdir = isForwards(pathj) ? pathj : flipDir(pathj);
@@ -182,6 +203,7 @@ namespace quda {
 
     __device__ __host__ void operator()(int x_cb, int parity, int dir)
     {
+      if(not arg.p.per_dir and not arg.p.run_dir[dir]) return;
       switch(dir) {
       case 0: GaugeForceKernel<Arg,0>(arg, x_cb, parity); break;
       case 1: GaugeForceKernel<Arg,1>(arg, x_cb, parity); break;
diff --git a/lib/gauge_force.cu b/lib/gauge_force.cu
index 476de20..250d4d4 100644
--- a/lib/gauge_force.cu
+++ b/lib/gauge_force.cu
@@ -45,13 +45,13 @@ namespace quda {
 
 #ifdef GPU_GAUGE_FORCE
   void gaugeForce(GaugeField& mom, const GaugeField& u, double epsilon, int ***input_path,
-                  int *length_h, double *path_coeff_h, int num_paths, int path_max_length)
+                  int *length_h, double *path_coeff_h, int num_paths, int path_max_length, bool per_dir)
   {
     checkPrecision(mom, u);
     checkLocation(mom, u);
     if (mom.Reconstruct() != QUDA_RECONSTRUCT_10) errorQuda("Reconstruction type %d not supported", mom.Reconstruct());
 
-    paths p(input_path, length_h, path_coeff_h, num_paths, path_max_length);
+    paths p(input_path, length_h, path_coeff_h, num_paths, path_max_length, per_dir);
 
     // gauge field must be passed as first argument so we peel off its reconstruct type
     instantiate<GaugeForce_,ReconstructNo12>(u, mom, epsilon, p);
@@ -59,24 +59,24 @@ namespace quda {
   }
   
   void gaugePath(GaugeField& out, const GaugeField& u, double coeff, int ***input_path,
-		 int *length_h, double *path_coeff_h, int num_paths, int path_max_length)
+		 int *length_h, double *path_coeff_h, int num_paths, int path_max_length, bool per_dir)
   {
     checkPrecision(out, u);
     checkLocation(out, u);
     checkReconstruct(out, u);
 
-    paths p(input_path, length_h, path_coeff_h, num_paths, path_max_length);
+    paths p(input_path, length_h, path_coeff_h, num_paths, path_max_length, per_dir);
 
     // gauge field must be passed as first argument so we peel off its reconstruct type
     instantiate<GaugePath>(u, out, coeff, p);
     p.free();
   }
 #else
-  void gaugeForce(GaugeField&, const GaugeField&, double, int ***, int *, double *, int, int)
+  void gaugeForce(GaugeField&, const GaugeField&, double, int ***, int *, double *, int, int, bool)
   {
     errorQuda("Gauge force has not been built");
   }
-  void gaugePath(GaugeField&, const GaugeField&, double, int ***, int *, double *, int, int)
+  void gaugePath(GaugeField&, const GaugeField&, double, int ***, int *, double *, int, int, bool)
   {
     errorQuda("Gauge force has not been built");
   }
