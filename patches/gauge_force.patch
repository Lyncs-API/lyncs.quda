diff --git a/include/gauge_force_quda.h b/include/gauge_force_quda.h
index 6bf0477..4d3b58f 100644
--- a/include/gauge_force_quda.h
+++ b/include/gauge_force_quda.h
@@ -13,9 +13,11 @@ namespace quda {
      @param[in] path_coeff Coefficient of each path
      @param[in] num_paths Numer of paths
      @param[in] max_length Maximum length of each path
+     @param[in] per_dir (default true) Whether the input_path is given per direction
+                        or as a list of path where the first value indicates the direction
    */
   void gaugeForce(GaugeField& mom, const GaugeField& u, double coeff, int ***input_path,
-		  int *length, double *path_coeff, int num_paths, int max_length);
+		  int *length, double *path_coeff, int num_paths, int max_length, bool per_dir=true);
 
   /**
      @brief Compute the product of gauge-links along the given path
@@ -27,9 +29,29 @@ namespace quda {
      @param[in] path_coeff Coefficient of each path
      @param[in] num_paths Numer of paths
      @param[in] max_length Maximum length of each path
+     @param[in] per_dir (default true) Whether the input_path is given per direction
+                        or as a list of path where the first value indicates the direction
    */
-  void gaugePath(GaugeField &out, const GaugeField &u, double coeff, int ***input_path, int *length, double *path_coeff,
-                 int num_paths, int max_length);
+  void gaugePath(GaugeField &out, const GaugeField &u, double coeff, int ***input_path,
+		 int *length, double *path_coeff, int num_paths, int max_length, bool per_dir=true);
+
+  /**
+     @brief Compute the gauge-force gradient in direction du
+     @param[out] mom Momentum field
+     @param[in] u Gauge field (extended when running on multiple GPUs)
+     @param[in] du Momentum field (extended when running on multiple GPUs)
+     @param[in] coeff Step-size coefficient
+     @param[in] input_path Host-array holding all path contributions for the gauge action
+     @param[in] length Host array holding the length of all paths
+     @param[in] path_coeff Coefficient of each path
+     @param[in] num_paths Numer of paths
+     @param[in] max_length Maximum length of each path
+     @param[in] per_dir (default true) Whether the input_path is given per direction
+                        or as a list of path where the first value indicates the direction
+   */
+  void gaugeForceGradient(GaugeField& mom, const GaugeField& u, const GaugeField& du, double coeff, int ***input_path,
+			  int *length, double *path_coeff, int num_paths, int max_length, bool per_dir=true, bool left=false);
+
 } // namespace quda
 
 
diff --git a/include/kernels/gauge_force.cuh b/include/kernels/gauge_force.cuh
index 09b7f97..b7efe19 100644
--- a/include/kernels/gauge_force.cuh
+++ b/include/kernels/gauge_force.cuh
@@ -16,14 +16,21 @@ namespace quda {
     const double *path_coeff;
     int *buffer;
     int count;
+    bool per_dir;
+    bool run_dir[4];
+    bool left;
 
-    paths(int ***input_path, int *length_h, double *path_coeff_h, int num_paths, int max_length) :
+    paths(int ***input_path, int *length_h, double *path_coeff_h, int num_paths, int max_length, bool per_dir, bool left=false) :
       num_paths(num_paths),
       max_length(max_length),
-      count(0)
+      count(0),
+      per_dir(per_dir),
+      run_dir({per_dir,per_dir,per_dir,per_dir}),
+      left(left)
     {
       // create path struct in a single allocation
-      size_t bytes = 4 * num_paths * max_length * sizeof(int) + num_paths * sizeof(int);
+      int ndirs = per_dir ? 4 : 1;
+      size_t bytes = ndirs * num_paths * max_length * sizeof(int) + num_paths * sizeof(int);
       int pad = ((sizeof(double) - bytes % sizeof(double)) % sizeof(double))/sizeof(int);
       bytes += pad*sizeof(int) + num_paths*sizeof(double);
 
@@ -31,10 +38,17 @@ namespace quda {
       int *path_h = static_cast<int*>(safe_malloc(bytes));
       memset(path_h, 0, bytes);
 
-      for (int dir=0; dir<4; dir++) {
+      for (int dir=0; dir<ndirs; dir++) {
         // flatten the input_path array for copying to the device
         for (int i=0; i < num_paths; i++) {
           for (int j=0; j < length_h[i]; j++) {
+	    // checking that if not per_dir, first link is in positive direction
+	    if (not per_dir and j==0) {
+	      if(input_path[dir][i][j]>3) {
+		errorQuda("First path element must be in a positive direction");
+	      }
+	      run_dir[input_path[dir][i][j]]=true;
+	    }
             path_h[dir*num_paths*max_length + i*max_length + j] = input_path[dir][i][j];
             if (dir==0) count++;
           }
@@ -42,18 +56,18 @@ namespace quda {
       }
 
       // length array
-      memcpy(path_h + 4 * num_paths * max_length, length_h, num_paths*sizeof(int));
+      memcpy(path_h + ndirs * num_paths * max_length, length_h, num_paths*sizeof(int));
 
       // path_coeff array
-      memcpy(path_h + 4 * num_paths * max_length + num_paths + pad, path_coeff_h, num_paths*sizeof(double));
+      memcpy(path_h + ndirs * num_paths * max_length + num_paths + pad, path_coeff_h, num_paths*sizeof(double));
 
       qudaMemcpy(buffer, path_h, bytes, qudaMemcpyHostToDevice);
       host_free(path_h);
 
       // finally set the pointers to the correct offsets in the buffer
-      for (int d=0; d < 4; d++) this->input_path[d] = buffer + d*num_paths*max_length;
-      length = buffer + 4*num_paths*max_length;
-      path_coeff = reinterpret_cast<double*>(buffer + 4 * num_paths * max_length + num_paths + pad);
+      for (int d=0; d < ndirs; d++) this->input_path[d] = buffer + d*num_paths*max_length;
+      length = buffer + ndirs*num_paths*max_length;
+      path_coeff = reinterpret_cast<double*>(buffer + ndirs * num_paths * max_length + num_paths + pad);
     }
     void free() {
       pool_device_free(buffer);
@@ -61,16 +75,19 @@ namespace quda {
   };
 
 
-  template <typename Float_, int nColor_, QudaReconstructType recon_u, QudaReconstructType recon_m, bool force_>
+  template <typename Float_, int nColor_, QudaReconstructType recon_u, QudaReconstructType recon_m, bool force_, bool gradient_>
   struct GaugeForceArg : kernel_param<> {
     using Float = Float_;
     static constexpr int nColor = nColor_;
     static constexpr bool compute_force = force_;
+    static constexpr bool compute_gradient = gradient_;
     static_assert(nColor == 3, "Only nColor=3 enabled at this time");
     typedef typename gauge_mapper<Float,recon_u>::type Gauge;
     typedef typename gauge_mapper<Float,recon_m>::type Mom;
+    typedef typename gauge_mapper<Float,QUDA_RECONSTRUCT_10>::type dU;
 
     Mom mom;
+    const dU du;
     const Gauge u;
 
     int X[4]; // the regular volume parameters
@@ -80,10 +97,11 @@ namespace quda {
     Float epsilon; // stepsize and any other overall scaling factor
     const paths p;
 
-    GaugeForceArg(GaugeField &mom, const GaugeField &u, double epsilon, const paths &p) :
+    GaugeForceArg(GaugeField &mom, const GaugeField &u, const GaugeField &du, double epsilon, const paths &p) :
       kernel_param(dim3(mom.VolumeCB(), 2, 4)),
       mom(mom),
       u(u),
+      du(du),
       epsilon(epsilon),
       p(p)
     {
@@ -103,6 +121,8 @@ namespace quda {
   {
     using real = typename Arg::Float;
     typedef Matrix<complex<real>,Arg::nColor> Link;
+    class Empty {};
+    using Extra = typename std::conditional<Arg::compute_gradient, Link, Empty>::type;
 
     int x[4] = {0, 0, 0, 0};
     getCoords(x, idx, arg.X, parity);
@@ -111,60 +131,78 @@ namespace quda {
     //linkA: current matrix
     //linkB: the loaded matrix in this round
     Link linkA, linkB, staple;
+    Extra linkC, linkD, staple2;
     thread_array<int, 4> dx{0};
 
     for (int i=0; i<arg.p.num_paths; i++) {
       real coeff = arg.p.path_coeff[i];
       if (coeff == 0) continue;
 
-      const int* path = arg.p.input_path[dir] + i*arg.p.max_length;
+      const int* path = arg.p.input_path[arg.p.per_dir ? dir : 0] + i*arg.p.max_length;
+      if (not arg.p.per_dir and path[0] != dir) continue;
 
+      int length = arg.p.length[i];
+      if (not arg.p.per_dir) {
+	// Skipping first link
+	length -= 1;
+	path += 1;
+      }
+      
       // start from end of link in direction dir
+      for(int i=0; i<4; i++) dx[i] = 0;
       int nbr_oddbit = (parity^1);
       dx[dir]++;
 
-      int path0 = path[0];
-      int lnkdir = isForwards(path0) ? path0 : flipDir(path0);
-
-      if (isForwards(path0)) {
-        linkB = arg.u(lnkdir, linkIndexShift(x,dx,arg.E), nbr_oddbit);
-        linkA = linkB;
-        dx[lnkdir]++; // now have to update location
-	nbr_oddbit = nbr_oddbit^1;
-      } else {
-        dx[lnkdir]--; // if we are going backwards the link is on the adjacent site
-        nbr_oddbit = nbr_oddbit^1;
-	linkB = arg.u(lnkdir, linkIndexShift(x,dx,arg.E), nbr_oddbit);
-        linkA = conj(linkB);
-      }
-
-      for (int j=1; j<arg.p.length[i]; j++) {
+      for (int j=0; j<length; j++) {
 
         int pathj = path[j];
         int lnkdir = isForwards(pathj) ? pathj : flipDir(pathj);
 
-        if (isForwards(pathj)) {
-          linkB = arg.u(lnkdir, linkIndexShift(x,dx,arg.E), nbr_oddbit);
-          linkA = linkA * linkB;
-          dx[lnkdir]++; // now have to update to new location
-          nbr_oddbit = nbr_oddbit^1;
-        } else {
+	if (not isForwards(pathj)) {
           dx[lnkdir]--; // if we are going backwards the link is on the adjacent site
 	  nbr_oddbit = nbr_oddbit^1;
-          linkB = arg.u(lnkdir, linkIndexShift(x,dx,arg.E), nbr_oddbit);
-          linkA = linkA * conj(linkB);
-        }
+	}
+	linkB = arg.u(lnkdir, linkIndexShift(x,dx,arg.E), nbr_oddbit);
+	if (not isForwards(pathj)) linkB = conj(linkB);
+				     
+	if constexpr(Arg::compute_gradient) {
+	  linkC = arg.du(lnkdir, linkIndexShift(x,dx,arg.E), nbr_oddbit);
+	  if (isForwards(pathj)) linkC = linkC * linkB;
+	  else linkC = - linkB * linkC;
+	  if (j==0) linkD = linkC;
+	  else linkD = linkD * linkB + linkA * linkC;
+	}
+
+	if (j==0) linkA = linkB;
+	else linkA = linkA * linkB;
+
+	if (isForwards(pathj)) {
+          dx[lnkdir]++; // if we go forward now have to update to new location
+          nbr_oddbit = nbr_oddbit^1;
+	}	  
       } //j
       staple = staple + coeff*linkA;
+      if constexpr(Arg::compute_gradient) {
+	staple2 = staple2 + coeff*linkD;
+      }
     } //i
 
     // multiply by U(x)
     linkA = arg.u(dir, linkIndex(x,arg.E), parity);
-    linkA = linkA * staple;
+    if constexpr(Arg::compute_gradient) {
+      linkC = arg.du(dir, linkIndex(x,arg.E), parity);
+      if (arg.p.left) {
+	linkA = linkA * staple2 + linkA * staple * linkC;
+      } else {
+	linkA = linkA * staple2 + linkC * linkA * staple;
+      }
+    } else {
+      linkA = linkA * staple;
+    }
 
     // update mom(x)
     Link mom = arg.mom(dir, idx, parity);
-    if(arg.compute_force) {
+    if constexpr(Arg::compute_force) {
       mom = mom - arg.epsilon * linkA;
       makeAntiHerm(mom);
     }
@@ -182,6 +220,7 @@ namespace quda {
 
     __device__ __host__ void operator()(int x_cb, int parity, int dir)
     {
+      if(not arg.p.per_dir and not arg.p.run_dir[dir]) return;
       switch(dir) {
       case 0: GaugeForceKernel<Arg,0>(arg, x_cb, parity); break;
       case 1: GaugeForceKernel<Arg,1>(arg, x_cb, parity); break;
diff --git a/lib/gauge_force.cu b/lib/gauge_force.cu
index 476de20..aba7936 100644
--- a/lib/gauge_force.cu
+++ b/lib/gauge_force.cu
@@ -4,18 +4,20 @@
 
 namespace quda {
 
-  template <typename Float, int nColor, QudaReconstructType recon_u, bool compute_force=true> class ForceGauge : public TunableKernel3D
+  template <typename Float, int nColor, QudaReconstructType recon_u, bool compute_force=true, bool compute_gradient=false> class ForceGauge : public TunableKernel3D
   {
     const GaugeField &u;
+    const GaugeField &du;
     GaugeField &mom;
     double epsilon;
     const paths &p;
     unsigned int minThreads() const { return mom.VolumeCB(); }
 
   public:
-    ForceGauge(const GaugeField &u, GaugeField &mom, double epsilon, const paths &p) :
+    ForceGauge(const GaugeField &u, GaugeField &mom, const GaugeField &du, double epsilon, const paths &p) :
       TunableKernel3D(u, 2, 4),
       u(u),
+      du(du),
       mom(mom),
       epsilon(epsilon),
       p(p)
@@ -29,7 +31,7 @@ namespace quda {
     void apply(const qudaStream_t &stream)
     {
       TuneParam tp = tuneLaunch(*this, getTuning(), getVerbosity());
-      launch<GaugeForce>(tp, stream, GaugeForceArg<Float, nColor, recon_u, compute_force ? QUDA_RECONSTRUCT_10 : recon_u, compute_force>(mom, u, epsilon, p));
+      launch<GaugeForce>(tp, stream, GaugeForceArg<Float, nColor, recon_u, compute_force ? QUDA_RECONSTRUCT_10 : recon_u, compute_force, compute_gradient>(mom, u, du, epsilon, p));
     }
 
     void preTune() { mom.backup(); }
@@ -39,44 +41,69 @@ namespace quda {
     long long bytes() const { return (p.count + 1ll) * u.Bytes() + 2 * mom.Bytes(); }
   };
 
-  template<typename Float, int nColor, QudaReconstructType recon_u> using GaugeForce_ = ForceGauge<Float,nColor,recon_u,true>;
+  template<typename Float, int nColor, QudaReconstructType recon_u> using GaugeForceGradientNoProj = ForceGauge<Float,nColor,recon_u,false,true>;
+  
+  template<typename Float, int nColor, QudaReconstructType recon_u> using GaugeForceGradient = ForceGauge<Float,nColor,recon_u,true,true>;
+
+  template<typename Float, int nColor, QudaReconstructType recon_u> using GaugeForce_ = ForceGauge<Float,nColor,recon_u,true,false>;
 
-  template<typename Float, int nColor, QudaReconstructType recon_u> using GaugePath = ForceGauge<Float,nColor,recon_u,false>;
+  template<typename Float, int nColor, QudaReconstructType recon_u> using GaugePath = ForceGauge<Float,nColor,recon_u,false,false>;
 
 #ifdef GPU_GAUGE_FORCE
+  void gaugeForceGradient(GaugeField& mom, const GaugeField& u, const GaugeField& du, double epsilon, int ***input_path,
+			  int *length_h, double *path_coeff_h, int num_paths, int path_max_length, bool per_dir, bool left)
+  {
+    checkPrecision(mom, u, du);
+    checkLocation(mom, u, du);
+    if (du.Reconstruct() != QUDA_RECONSTRUCT_10) errorQuda("Reconstruction type %d not supported", du.Reconstruct());
+
+    paths p(input_path, length_h, path_coeff_h, num_paths, path_max_length, per_dir, left);
+
+    // gauge field must be passed as first argument so we peel off its reconstruct type
+    if (mom.Reconstruct() == QUDA_RECONSTRUCT_10)
+      instantiate<GaugeForceGradient,ReconstructNo12>(u, mom, du, epsilon, p);
+    else
+      instantiate<GaugeForceGradientNoProj,ReconstructNo12>(u, mom, du, epsilon, p);      
+    p.free();
+  }
+  
   void gaugeForce(GaugeField& mom, const GaugeField& u, double epsilon, int ***input_path,
-                  int *length_h, double *path_coeff_h, int num_paths, int path_max_length)
+                  int *length_h, double *path_coeff_h, int num_paths, int path_max_length, bool per_dir)
   {
     checkPrecision(mom, u);
     checkLocation(mom, u);
     if (mom.Reconstruct() != QUDA_RECONSTRUCT_10) errorQuda("Reconstruction type %d not supported", mom.Reconstruct());
 
-    paths p(input_path, length_h, path_coeff_h, num_paths, path_max_length);
+    paths p(input_path, length_h, path_coeff_h, num_paths, path_max_length, per_dir);
 
     // gauge field must be passed as first argument so we peel off its reconstruct type
-    instantiate<GaugeForce_,ReconstructNo12>(u, mom, epsilon, p);
+    instantiate<GaugeForce_,ReconstructNo12>(u, mom, u, epsilon, p);
     p.free();
   }
   
   void gaugePath(GaugeField& out, const GaugeField& u, double coeff, int ***input_path,
-		 int *length_h, double *path_coeff_h, int num_paths, int path_max_length)
+		 int *length_h, double *path_coeff_h, int num_paths, int path_max_length, bool per_dir)
   {
     checkPrecision(out, u);
     checkLocation(out, u);
     checkReconstruct(out, u);
 
-    paths p(input_path, length_h, path_coeff_h, num_paths, path_max_length);
+    paths p(input_path, length_h, path_coeff_h, num_paths, path_max_length, per_dir);
 
     // gauge field must be passed as first argument so we peel off its reconstruct type
-    instantiate<GaugePath>(u, out, coeff, p);
+    instantiate<GaugePath>(u, out, u, coeff, p);
     p.free();
   }
 #else
-  void gaugeForce(GaugeField&, const GaugeField&, double, int ***, int *, double *, int, int)
+  void gaugeForceGradient(GaugeField&, const GaugeField&, const GaugeField&, double, int ***, int *, double *, int, int, bool)
+  {
+    errorQuda("Gauge force has not been built");
+  }
+  void gaugeForce(GaugeField&, const GaugeField&, double, int ***, int *, double *, int, int, bool)
   {
     errorQuda("Gauge force has not been built");
   }
-  void gaugePath(GaugeField&, const GaugeField&, double, int ***, int *, double *, int, int)
+  void gaugePath(GaugeField&, const GaugeField&, double, int ***, int *, double *, int, int, bool)
   {
     errorQuda("Gauge force has not been built");
   }
